<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Cow Abducting Simulator</title>
    <style>* { padding: 0; margin: 0; } canvas { margin: 5; background: #eeeeee; display: block; border: solid 3px blue; }</style>
</head>
<body>
    <div width="100%" style="align-content:center">
        <canvas id="myCanvas"></canvas>
    </div>
    <div style="text-align: center;">
        <h1>Cow Abducting Simulator</h1>
        <dl>
            <dt>Autopilot mode:</dt>
            <dd>Ship will follow your mouse cursor.</dd>
            <dt>Manual mode:</dt>
            <dd>Use arrow keys or "w", "a", "s", "d" to control the rockets yourself.</dd>
            <dt>Pause:</dt>
            <dd>Press "Esc" to pause.</dd>
        </dl>
        
        <p> Try moving your mouse around and clicking. It'll get more fun when we add cows. :)</p>
        <p>By Oliver, Ben, and Carter Martin</p>
    </div>
    <!--
        var randomCowGoalPosition = function(cowWidth, cowHeight) {
            return [
            Math.random(cowWidth/2, bg.size[0] - cowWidth/2),
            bg.size[1] - 100 / 2 - cowHeight / 2,
            ];
        };
        
        var makeCow = function(startX, startY, startWidth, startHeight) {
            var cow = {
                "pos" : [ startX, startY ],
                "size" : [ startWidth, startHeight ],
                "v" : [ 0, 0],
                "maxV" : [ 3, 5 ],
                "goal" : [ startX, startY ],
                "update" : function() {
                    // Move with previous speed
                    for (var i = 0; i < 2; i++) {
                        // Move in current direction
                        this.pos[i] = this.pos[i] + this.v[i];
                        if (this.pos[i] - this.size[i] / 2 < 0) {
                            this.pos[i] = this.size[i] / 2;
                            this.v[i] = 0;
                        }
                        if (this.pos[i] + this.size[i] / 2 > bg.size[i]) {
                            this.pos[i] = bg.size[i] - this.size[i] / 2;
                            this.v[i] = 0;
                        }
                    }
                    
                    // Update speed
                    for (var i = 0; i < 2; i++) {
                        var err = this.goal[i] - this.pos[i];
                        if (err < 0) {
                            if (this.v[i] > - this.maxV[i]) {
                                this.v[i] = this.v[i] - 1;
                            }
                        } else {
                            if (this.v[i] < this.maxV[i]) {
                                this.v[i] = this.v[i] + 1;
                            }
                        }
                    }
                    
                    var xSatisfied = abs(this.goal[0] - this.pos[0]) < this.size[0]/2;
                    var ySatisfied = abs(this.goal[1] - this.pos[1]) < this.size[1]/2;
                    if (xSatisfied && ySatisfied) {
                        this.goal = randomCowGoalPosition(this.size[0], this.size=
                        [1]);
                    }
                },
                "draw": function(view) {
                    var x = this.pos[0] - view[0];
                    var y = this.pos[1] - view[1];
                    
                    //cockpit
                    fill(95, 199, 199);
                    ellipse(x, y - this.size[1] / 2, this.size[0] * 3 / 4, this.size[1] );
                    //body
                    fill(230, 230, 230);
                    ellipse(x, y, this.size[0], this.size[1]);
                    //body
                    fill(222, 22, 22);
                    ellipse(x, y, this.size[0], 2);
                }
            };
            return cow;
        };
        
        for (var i = 0; i < 10; i++) {
            var cowWidth = Math.random(50, 100);
            var cowHeight = cowWidth/2;
            var cowStartPos = randomCowGoalPosition(cowWidth, cowHeight);
            cows.push(makeCow(cowStartPos[0], cowStartPos[1],
            cowWidth,
            cowHeight
            ));
        }
        for (var i = 0; i < cows.length; i++) {
            bg.objects.push(cows[i]);
        }
        
        // debug(bg);
        
        mouseClicked = function() {
            ship.beams.push(ship.beamStartSize);
        };
        
        draw = function() {
            ship.goal = [mouseX + bg.view[0], mouseY + bg.view[1]];
            
            // Simulation
            bg.update();
            
            // Drawing
            bg.draw();
            
            return;
        };
    -->
    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        
        ctx.canvas.width = innerWidth - 100;
        ctx.canvas.height = innerHeight * .9;
        
        var rightPressed = false;
        var leftPressed  = false;
        var upPressed    = false;

        function createInvisibleBoundingBox (pos, size, bounce_rho) {
            // No mass is the same as infinite                                
            var o = {
                "pos"  : pos,
                "size" : size,
                "v"    : [0, 0],
                "a"    : [0, 0],
                "bounce_rho" : bounce_rho
            };
            return o;
        }

        var w = 200;
        var h = 100;
        var world = {
            "size" : [w, h],
            "objects" : [],
            // pixels / m
            // Initial value is width of screen.
            "zoom" : canvas.width / w,
            "view" : [0, 0, w, h],
            // in m/s
            "g" : 9.8,
            "focus" : null,
            "drawBoundingBoxes" : false,
            handleMouseMove : function(relativeX, relativeY) {
                // Convert to world space
                var x = relativeX / this.zoom + this.view[0];
                var y = relativeY / this.zoom + this.view[1];
                
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleMouseMove) {
                        this.objects[i].handleMouseMove(x, y);
                    }
                }
                
                return;
            },
            handleClick : function(relativeX, relativeY) {
                var x = relativeX / this.zoom + this.view[0];
                var y = relativeY / this.zoom + this.view[1];
                
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleClick) {
                        this.objects[i].handleClick(x, y);
                    }
                }
                
                return;
            },
            handleKeyDown : function(e) {
                if(e.keyCode == 66) {
                    // pushed b
                    world.drawBoundingBoxes = true;
                } else {
                    // Pass along to objects
                    for (var i = 0; i < this.objects.length; i++) {
                        if (this.objects[i].handleKeyDown) {
                            this.objects[i].handleKeyDown(e);
                        }
                    }
                }
                return;
            },
            handleKeyUp : function(e) {
                if(e.keyCode == 66) {
                    // pushed b
                    world.drawBoundingBoxes = false;
                } else {
                    // Pass along to objects
                    for (var i = 0; i < this.objects.length; i++) {
                        if (this.objects[i].handleKeyUp) {
                            this.objects[i].handleKeyUp(e);
                        }
                    }
                }
                return;
            },
            "draw": function() {
                // console.log("drawing world");
                
                // Update viewport to keep focus item in center 1/2 of screen if possible
                if (this.focus) {
                    // First, adjust zoom based on bottom of focus object, such that object width is 100 at bottom and 50 at top.
                    
                    this.zoom = 100 / this.focus.size[0];
                    //  *
                    //     (1 + (1-(this.size[1] - this.focus.pos[1] - this.focus.size[1]) / this.size[1]));
                    // if (this.zoom < 1) {
                    //     this.zoom = 1;
                    // } else if (this.zoom > 5) {
                    //     this.zoom = 5;
                    // }
                    this.view[2] = canvas.width  / this.zoom;
                    this.view[3] = canvas.height / this.zoom;
                    
                    // Now center view. Desired state is for view and focus to have same center:
                    //   this.view[i] + this.view[i+2]/2 = focus.pos[i] + focus.size[i] / 2
                    // or
                    //   this.view[i] = focus.pos[i] + focus.size[i] / 2 - this.view[i+2]/2
                    //
                    // For stability, only correct if desired position is more than 1/4 of the screen away,
                    // and then, only as much as is needed to be that far.
                    for (var i = 0; i < 2; i++) {
                        var desiredViewPos = this.focus.pos[i] + this.focus.size[i] / 2 - this.view[i+2]/2;
                        if (this.view[i] < desiredViewPos - this.view[i+2] / 4) {
                            this.view[i] = desiredViewPos - this.view[i+2] / 4;
                        }
                        if (this.view[i] > desiredViewPos + this.view[i+2] / 4) {
                            this.view[i] = desiredViewPos + this.view[i+2] / 4;
                        }
                        // Make sure view is legal
                        if (this.view[i] < 0) {
                            this.view[i] = 0;
                        }
                        if (this.view[i] + this.view[i+2] > this.size[i]) {
                            this.view[i] = this.size[i] - this.view[i+2];
                        }
                    }
                } else {
                    this.zoom = canvas.width / this.size[0];
                    this.view[2] = canvas.height / this.zoom;
                    this.view[3] = canvas.width  / this.zoom;
                }
                        
                for (var i = 0; i < this.objects.length; i++) {
                    var o = this.objects[i];
                    if ('size' in o) {
                        var visible =
                            (o.pos[0] + o.size[0] > this.view[0]) &&
                            (o.pos[1] + o.size[1] > this.view[1]) &&
                            (o.pos[0] < this.view[0] + this.view[2]) &&
                            (o.pos[1] < this.view[1] + this.view[3]);
                        if (visible) {
                            var zoom = this.zoom;
                            var box = [zoom * (o.pos[0] - this.view[0]),
                                       zoom * (o.pos[1] - this.view[1]),
                                       zoom * o.size[0],
                                       zoom * o.size[1]];
                            if (o.draw && !o.hidden) {
                                o.draw(box);
                            }
                            if (this.drawBoundingBoxes && 'pos' in o && 'size' in o) {
                                ctx.strokeStyle = "green";
                                ctx.strokeRect(box[0], box[1], box[2], box[3]);
                            }
                        }
                    } else if ("draw" in o && !o.hidden) {
                        // dimensionless object to draw
                        o.draw([0, 0, canvas.width, canvas.height]);
                    }
                }
                
                return;
            },
            "update" : function(delta_ms) {
                for (var i = 0; i < this.objects.length; i++) {
                    if ('update' in this.objects[i]) {
                        this.objects[i].update(delta_ms);
                    }
                }
                return;
            }
        };

        // Add bounding box around world to keep physics objects in.
        world.objects.push(createInvisibleBoundingBox([-1,            -1], [world.size[0] + 2, 2], 1));
        world.objects.push(createInvisibleBoundingBox([-1, world.size[0]], [world.size[0] + 2, 2], 1));
        world.objects.push(createInvisibleBoundingBox([-1,            -1], [2, world.size[1] + 2], 1));
        world.objects.push(createInvisibleBoundingBox([world.size[0], -1], [2, world.size[1] + 2], 1));
       
        function createStarField(x, y, w, h, numStars) {
            var starField = {
                pos : [x, y],
                "size" : [w, h],
                "stars" : [],
                "draw": function(box) {                
                    ctx.fillStyle = "#000";
                    ctx.fillRect(box[0], box[1], box[2], box[3]);
                    
                    // Star position obeys zoom, but size does not.
                    var zoom = box[2] / this.size[0];
                    for (var i = 0; i < this.stars.length; i++) {
                        var star = this.stars[i];
                        var screenX = star[0] * zoom + box[0];
                        var screenY = star[1] * zoom + box[1];
                        var screenR = star[2];
                        var visible = screenX + screenR > 0 && screenX - screenR < box[2] &&
                                      screenY + screenR > 0 && screenY - screenR < box[3]; 
                        if (visible) {
                            ctx.beginPath();
                            ctx.fillStyle = "#eee";
                            ctx.arc(screenX, screenY, screenR, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.closePath();
                        }
                    }
                    return;
                }
            };
            for (var i = 0; i < numStars; i++) {
                starField.stars.push([w * Math.random(), h * Math.random(), 5 * Math.random()]);
            }
            return starField;
        }
        world.objects.push(createStarField(0, 0, world.size[0], world.size[1], world.size[0] * world.size[1] / 100));
        
        function createGroundBackground(x, y, w, h) {
            var obj = {
                pos   : [x, y],
                size  : [w, h],
                draw  : function(box) {                
                    ctx.fillStyle = "#0e0";
                    ctx.fillRect(box[0], box[1], box[2], box[3]);
                    return;
                }
            };
            return obj;
        }
        // Bottom 10% of world is ground
        world.objects.push(createGroundBackground(0, world.size[1] - 0.1 * world.size[1], world.size[0], 0.1 * world.size[1]));

        // Bottom 5% is collision box for ground. Ground is moderately bouncy
        world.objects.push(createInvisibleBoundingBox([0, 0.95 * world.size[1]], [world.size[0], 1], .75));

        var updatePhysicsSub = function(delta_ms) {
            var delta_s =  delta_ms / 1000.0;
            
            // Update speed (subject to collision)
            for (var i = 0; i < 2; i++) {
                this.v[i] = this.v[i] + this.a[i] * delta_s;
            }

            // Move with previous speed
            var next_pos = [
                this.pos[0] + this.v[0] * delta_s,
                this.pos[1] + this.v[1] * delta_s
            ];
            
            // Collision detection
            var first_collide_obj = null;
            var first_collide_pos = [...next_pos];
            var first_collide_v = [...this.v];
            var first_collide_distance = Math.sqrt(
                (next_pos[0] - this.pos[0]) * (next_pos[0] - this.pos[0])
                + (next_pos[1] - this.pos[1]) * (next_pos[1] - this.pos[1]));
    
            OTHER:
            for (var iObj = 0; iObj < world.objects.length; iObj++) {
                var other = world.objects[iObj];
                if (other === this) {
                    continue OTHER;
                }
                if (!('bounce_rho' in other)) {
                    // not a physics object
                    continue OTHER;
                }
                // Need to check for intersection
                //      --      --
                //     |  | -> |  |
                //      --      --

                var collide_pos = [...next_pos];
                var collide_v = [...this.v];
                for (var i = 0; i < 2; i++) {
                    if (this.v[i] > 0) {
                        if (this.pos[i] > other.pos[i] + other.size[i]) {
                            // Already past object
                            //     [other] [this]->
                            continue OTHER;
                        } else if (next_pos[i] + this.size[i] < other.pos[i]) {
                            // Doesn't reach object
                            //     [this]-> [other]
                            continue OTHER;
                        } else {
                            // Might collide
                            //     [this]---[-> other]
                            collide_pos[i] = other.pos[i] - this.size[i] - Number.EPSILON;
                            // ToDo: Add conservation of momentum.
                            collide_v[i] = -1 * this.bounce_rho * other.bounce_rho * this.v[i];
                        }
                    } else if (this.v[i] < 0) {
                        if (this.pos[i] + this.size[i] < other.pos[i]) {
                            // Already past object
                            //     <-[this] [other]
                            continue OTHER;
                        } else if (next_pos[i] > other.pos[i] + other.size[i]) {
                            // Doesn't reach object
                            //     [other] <-[this]
                            continue OTHER;
                        } else {
                            // Might collide
                            //     [other<-]--[this]
                            collide_pos[i] = other.pos[i] + other.size[i] + Number.EPSILON;
                            // ToDo: Add conservation of momentum.
                            collide_v[i] = -1 * this.bounce_rho * other.bounce_rho * this.v[i];
                        }
                    } else {
                        if (this.pos[i] + this.size[i] < other.pos[i]) {
                            // Before object
                            //     [this] [other]
                            continue OTHER;
                        } else if (this.pos[i] > other.pos[i] + other.size[i]) {
                            // After object
                            //     [other] [this]
                            continue OTHER;
                        }
                    }
                }

                // If we got here, then they collided. Now see if this was the first collision
                var collide_distance = Math.sqrt(
                    (collide_pos[0] - this.pos[0]) * (collide_pos[0] - this.pos[0])
                    + (collide_pos[1] - this.pos[1]) * (collide_pos[1] - this.pos[1])
                );
                if (collide_distance < first_collide_distance) {
                    // Tentatively mark this as the first collision
                    first_collide_obj = other;
                    first_collide_distance = collide_distance;
                    first_collide_pos = collide_pos;
                    first_collide_v = collide_v;
                }
            }

            this.pos = first_collide_pos;
            this.v = first_collide_v;

            // Stay in play-field (remove once edges have bounding boxes.)
            for (var i = 0; i < 2; i++) {
                // Move in current direction
                if (this.pos[i] < 0) {
                    this.pos[i] = 0;
                    // Bounce off side wall
                    this.v[i] = this.bounce_rho * Math.abs(this.v[i]);
                }
                if (this.pos[i] + this.size[i] > world.size[i]) {
                    this.pos[i] = world.size[i] - this.size[i];
                    this.v[i] = -1 * this.bounce_rho * Math.abs(this.v[i]);
                }
            }

            return;
        };
        
        function createHayBale (startX, startY) {
            
            // 16" x 18" x 4', 100 lb
            var w_m = 4 * 12 * 2.54 / 100;
            var h_m = 16 * 2.54 / 100;
            var d_m = 18 * 2.54 / 100;

            // Mass is a function of the volume.
            // Approximate as sphere of 50% aluminum by volume.
            // Aluminum is 2.7 g/cm^3, which is 2,710kg/m^3
            var volume_m3 = w_m * h_m * d_m;
            var mass_kg = 100 / 2.2;
                                
            var o = {
                "pos"  : [startX, startY],
                "size" : [w_m, h_m],
                "v"    : [0, 0],
                "a"    : [0, 0],
                "mass_kg" : mass_kg,
                "bounce_rho" : 0.1,
                "draw": function(box) {
                    // console.log("drawing ship");
                    
                    var x = box[0];
                    var y = box[1];
                    var w = box[2];
                    var h = box[3];

                    // front
                    ctx.fillStyle = "rgb(255, 186, 20)";
                    ctx.beginPath();
                    ctx.moveTo(x + 0.2 * w, y + 0.2 * h);
                    ctx.lineTo(x + 0.2 * w, y + 1.0 * h);
                    ctx.lineTo(x + 1.0 * w, y + 1.0 * h);
                    ctx.lineTo(x + 1.0 * w, y + 0.2 * h);
                    ctx.lineTo(x + 0.2 * w, y + 0.2 * h);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    // top
                    ctx.fillStyle = "rgb(248, 235, 0)";
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 0.2 * w, y + 0.2 * h);
                    ctx.lineTo(x +       w, y + 0.2 * h);
                    ctx.lineTo(x + 0.8 * w, y);
                    ctx.lineTo(x, y);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    // left side
                    ctx.fillStyle = "rgb(255, 210, 5)";
                    ctx.strokeStyle = "rgb(185, 130, 0)";
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + .2 * w, y + 0.2 * h);
                    ctx.lineTo(x + .2 * w, y +       h);
                    ctx.lineTo(x,          y + 0.8 * h);
                    ctx.lineTo(x, y);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    // rope
                    ctx.beginPath();
                    ctx.moveTo(x + 0.25 * w, y + 0.0 * h);
                    ctx.lineTo(x + 0.45 * w, y + 0.2 * h);
                    ctx.lineTo(x + 0.45 * w, y + 1.0 * h);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.beginPath();
                    ctx.moveTo(x + 0.55 * w, y + 0.0 * h);
                    ctx.lineTo(x + 0.75 * w, y + 0.2 * h);
                    ctx.lineTo(x + 0.75 * w, y + 1.0 * h);
                    ctx.stroke();
                    ctx.closePath();
                },
                "updatePhysics" : updatePhysicsSub,
                "update" : function(delta_ms) {
                    
                    // Adjust acceleration based on input forces
                    var f = [0, 0];
                    
                    // Drag can be modeled more accurately than this.

                    // Density in atmospheres
                    var density = 1;
                    f[0] = f[0] - Math.sign(this.v[0]) * 0.1 * density * this.v[0] * this.v[0];
                    f[1] = f[1] - Math.sign(this.v[0]) * 0.1 * density * this.v[1] * this.v[1];
                    
                    // Gravity
                    //   F = m * a => F = m * g
                    if (this.mass_kg) {
                        f[1] = f[1] + world.g * this.mass_kg;
                    }
            
                    this.a[0] = f[0] / this.mass_kg;
                    this.a[1] = f[1] / this.mass_kg;
                    
                    // Move based on acceleration
                    this.updatePhysics(delta_ms);
                }
            };
            return o;
        }

        function createShip (width_m) {
            
            // Mass is a function of the volume.
            // Approximate as sphere of 50% aluminum by volume.
            // Aluminum is 2.7 g/cm^3, which is 2,710kg/m^3
            var volume_m3 = 4 / 3 * Math.PI * (width_m / 2);
            var mass_kg = volume_m3 * 2710;
            
            // Define thrusters based on force required to accelerate at 1g.
            var liftingForce = mass_kg * 9.8;
            
            var ship = {
                "pos"  : [0, 0],
                "size" : [width_m, 0.75 * width_m],
                "v"    : [0, 0],
                "a"    : [0, 0],
                "mass_kg" : mass_kg,
                "bounce_rho" : 0.9,
                "maxV" : [50, 50],
                "autopilot" : true,
                "goal" : [0, 0],
                "jets" : [0, 0, 0],
                "jetMaxForce" : [1 * liftingForce, 3 * liftingForce, 1 * liftingForce],
                "jetAngles" : [0, 1.5 * Math.PI, Math.PI],
                "beams" : [],
                // Measured in multiples of the ship height size
                "beamStartWidth" : 1,
                "beamHeight" : 5,
                "bodyStyle" : { "fillStyle" : "#eee", "strokeStyle" : "#444"},
                "accentStyle" : { "fillStyle" : "#e00", "strokeStyle" : "#000000ff"},
                "cockpitStyle" : { "fillStyle" : "rgb(95, 199, 199, 100)", "strokeStyle" : "rgb(40, 100, 100)"},
                "draw": function(box) {
                    // console.log("drawing ship");
                    
                    var x = box[0];
                    var y = box[1];
                    var xCenter = box[0] + box[2] / 2;
                    var yCenter = box[1] + box[3] / 2;
                    
                    // Draw jets last so we can see them
                    if (this.jets[0] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter - 1.0 * box[2], yCenter + box[3] / 5);
                        ctx.lineTo(xCenter - 1.2 * box[2], yCenter);
                        ctx.lineTo(xCenter - 1.0 * box[2], yCenter - box[3] / 5);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    if (this.jets[1] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter + box[2] / 5, yCenter + 1.0 * box[3]);
                        ctx.lineTo(xCenter,                    yCenter + 1.2 * box[3]);
                        ctx.lineTo(xCenter - box[2] / 5, yCenter + 1.0 * box[3]);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    if (this.jets[2] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter + 1.0 * box[2], yCenter + box[3] / 5);
                        ctx.lineTo(xCenter + 1.2 * box[2], yCenter);
                        ctx.lineTo(xCenter + 1.0 * box[2], yCenter - box[3] / 5);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    
                    // Draw beams behind body
                    var beamStartPos = [box[0] + box[2]/2, box[1] + box[3]];
                    var beamHeight = box[3] * this.beamHeight;
                    for (var i = 0; i < this.beams.length; i++) {
                        var beamWidth = this.beams[i] * box[2] / 2;
                        // transparent green beam
                        ctx.fillStyle = "#00ff0080";
                        ctx.beginPath();
                        ctx.moveTo(beamStartPos[0],             beamStartPos[1]);
                        ctx.lineTo(beamStartPos[0] - beamWidth, beamStartPos[1] + beamHeight);
                        ctx.lineTo(beamStartPos[0] + beamWidth, beamStartPos[1] + beamHeight);
                        ctx.lineTo(beamStartPos[0],             beamStartPos[1]);
                        ctx.fill();
                        ctx.closePath();
                    }
                    
                    //body
                    ctx.fillStyle   = this.bodyStyle.fillStyle;
                    ctx.strokeStyle = this.bodyStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.66 * box[3], 0.5 * box[2], 0.33 * box[3], 0, 1.7 * Math.PI, 1.3 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                    
                    //body stripe
                    ctx.fillStyle   = this.accentStyle.fillStyle;
                    ctx.strokeStyle = this.accentStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.66 * box[3], box[2]/2, 0.05 * box[3], 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                    
                    // cockpit
                    ctx.fillStyle   = this.cockpitStyle.fillStyle;
                    ctx.strokeStyle = this.cockpitStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.4 * box[3], 0.3 * box[2], 0.4 * box[3], 0, Math.PI, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                },
                "updatePhysics" : updatePhysicsSub,
                "updateAI" : function(delta_ms) {
                    var xCenter = this.pos[0] + this.size[0] / 2;
                    var yCenter = this.pos[1] + this.size[1] / 2;
                    
                    // Run autopilot
                    if (this.goal) {
                        var xErr = this.goal[0] - xCenter;
                        var yErr = this.goal[1] - yCenter;
                        
                        // Fire horizontal jets toward goal
                        if (this.v[0] < -this.maxV[0]) {
                            // Emergency shut off
                            this.jets[2] = 0;
                        } else {
                            if (xErr < 3 * this.v[0]) {
                                // Accelerate toward goal
                                this.jets[2] = 1;
                            } else {
                                // Coast
                                this.jets[2] = 0;
                            }
                        }
                        
                        if (this.v[0] > this.maxV[0]) {
                            // Emergency shut off
                            this.jets[0] = 0;
                        } else {
                            if (xErr > 3 * this.v[0]) {
                                // Accelerate toward goal
                                this.jets[0] = 1;
                            } else {
                                // Coast
                                this.jets[0] = 0;
                            }
                        }
                        
                        // Fire vertical jets toward goal
                        if (this.v[0] <= -this.maxV[0]) {
                            // Emergency thruster shut off
                            this.jets[1] = 0;
                        } else {
                            if (yErr < 3 * this.v[1]) {
                                // full power
                                this.jets[1] = 1;
                            } else {
                                this.jets[1] = 0;
                            }
                        }
                    }
                    return;
                },
                "update" : function(delta_ms) {
                    
                    if (this.autopilot) {
                        this.updateAI(delta_ms);
                    }
                    
                    // Adjust acceleration based on input forces
                    var f = [0, 0];
                    
                    // Drag can be modeled more accurately than this.
                    
                    // Density in atmospheres
                    var density = 1;
                    f[0] = f[0] - Math.sign(this.v[0]) * 0.1 * density * this.v[0] * this.v[0];
                    f[1] = f[1] - Math.sign(this.v[0]) * 0.1 * density * this.v[1] * this.v[1];
                    
                    // Gravity
                    //   F = m * a => F = m * g
                    if (this.mass_kg) {
                        f[1] = f[1] + world.g * this.mass_kg;
                    }
                    
                    // Jets
                    for (var i = 0; i < this.jets.length; i++) {
                        var force = this.jets[i] * this.jetMaxForce[i];
                        f[0] = f[0] + Math.cos(this.jetAngles[i]) * force;
                        f[1] = f[1] + Math.sin(this.jetAngles[i]) * force;
                    }
                    
                    // Update tractor beams
                    for (var i = 0; i < this.beams.length; i++) {
                        // Beams disappear over 1 second
                        this.beams[i] = this.beams[i] - this.beamStartWidth / 1000 * delta_ms;
                    }
                    // Delete empty beams
                    var beamNum = 0;
                    while (beamNum < this.beams.length) {
                        if (this.beams[beamNum] <= 0) {
                            this.beams.splice(beamNum, 1);
                        } else {
                            beamNum = beamNum + 1;
                        }
                    }
                    
                    // Try to pick up objects
                    var beamStartPos = [this.pos[0] + this.size[0] / 2, this.pos[1] + this.size[1]];
                    var beamHeight = this.size[1] * this.beamHeight;
                    for (var i = 0; i < world.objects.length; i++) {
                        var other = world.objects[i];
                        if (this === other) {
                            continue;
                        }
                        if (!('mass_kg' in other)) {
                            continue;
                        }
                        if (!('v' in other)) {
                            continue;
                        }
                        // Check if mob is in beam
                        if (other.pos[1] + other.size[1] < beamStartPos[1]) {
                            // other is above this ship
                            continue;
                        } else if (other.pos[1] > beamStartPos[1] + beamHeight) {
                            // Other is below beam
                            continue;
                        }
                        // Could be in  one of the beams
                        for (var j = 0; j < this.beams.length; j++) {
                            var beamWidth = this.beams[j] * this.size[1];
                            if (other.pos[0] > beamStartPos[0] - beamWidth && other.pos[0] < beamStartPos[0] + beamWidth) {
                                // In beam
                                other.v[1] = other.v[1] - 1;
                                // Pull down by weight of object picked up
                                f[1] = f[1] + other.mass_kg * world.g;
                            }
                        }
                    }

                    // Move based on acceleration
                    this.a[0] = f[0] / this.mass_kg;
                    this.a[1] = f[1] / this.mass_kg;
                    
                    this.updatePhysics(delta_ms);
                    
                    return;
                },
                handleMouseMove : function(x, y) {
                    this.autopilot = true;
                    
                    // Scale goal extra when in the border region
                    this.goal = [x, y];
                    for (var i = 0; i < 2; i++) {
                        if (this.goal[i] < world.view[i] + 0.25 * world.view[i+2]) {
                            this.goal[i] = 0;
                        }
                        if (this.goal[i] < 0) {
                            this.goal[i] = 0;
                        }
                        if (this.goal[i] > world.view[i] + 0.75 * world.view[i+2]) {
                            this.goal[i] = world.size[i];
                        }
                        if (this.goal[i] > world.size[i]) {
                            this.goal[i] = works.size[i];
                        }
                    }
                    return;
                },
                handleClick : function(x, y) {
                    this.beams.push(this.beamStartWidth);
                    return;
                },
                disableAutoPilot : function () {
                    if (this.autopilot) {
                        // Turn off all jets and turn off autopilot
                        for (var i = 0; i < this.jets.length; i++) {
                            this.jets[i] = 0;
                        }
                        this.autopilot = false;
                    }
                },
                handleKeyDown : function(e) {
                    if (e.keyCode == 39 || e.keyCode == 68) {
                        // pushed right
                        this.jets[0] = 1;
                        this.disableAutoPilot();
                    } else if(e.keyCode == 37 || e.keyCode == 65) {
                        // pushed left
                        this.jets[2] = 1;
                        this.disableAutoPilot();
                    } else if(e.keyCode == 38 || e.keyCode == 87) {
                        // pushed up
                        this.jets[1] = 1;
                        this.disableAutoPilot();
                    } else {
                        console.log(e.keyCode);
                    }
                    return;
                },
                handleKeyUp : function(e) {
                    if (e.keyCode == 39 || e.keyCode == 68) {
                        // pushed right or d
                        this.jets[0] = 0;
                    } else if(e.keyCode == 37 || e.keyCode == 65) {
                        // pushed left or a
                        this.jets[2] = 0;
                    } else if(e.keyCode == 38 || e.keyCode == 87) {
                        // pushed up or w
                        this.jets[1] = 0;
                    } else if(e.keyCode == 32) {
                        // drop a hay bale
                        world.objects.push(createHayBale(this.pos[0] + this.size[0] / 2, this.pos[1] + this.size[1]));
                    }
                    return;
                }
            };
            return ship;
        }

        function createSplashScreen() {
            var o = {
                hidden : false,
                draw: function(view) {
                    ctx.font = "30px Arial";
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText("Cow Abducting Simulator", canvas.width/2, canvas.height/2);
                    
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText("Click to Start", canvas.width/2, canvas.height * .75);
                    return;
                },
                handleClick : function(x, y) {
                    if (this.hidden) {
                        return;
                    }
                    this.hidden = true;
                    // Initial ship is 5m
                    var ship = createShip(5);
                    world.objects.push(ship);
                    world.focus = ship;
                    return;
                }
            };
            return o;
        }
        
        // Must be last object on stack
        world.objects.push(createSplashScreen());
        
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        document.addEventListener("mousemove", mouseMoveHandler, false);
        document.addEventListener("click", clickHandler, false);
        
        var paused = false;
        var last_now_ms = performance.now();
        
        function startPause () {
            paused = true;
        }
        function endPause () {
            paused = false;
            last_now_ms = performance.now();
            draw(performance.now());
        }
        
        function keyDownHandler(e) {
            if (e.keyCode == 27) {
                startPause();
            } else {
                if (paused) {
                    endPause();
                }
                world.handleKeyDown(e);
            }
        }
        function keyUpHandler(e) {
            world.handleKeyUp(e);
        }
        function mouseMoveHandler(e) {
            var relativeX = e.clientX - canvas.offsetLeft;
            var relativeY = e.clientY - canvas.offsetTop;
            
            world.handleMouseMove(relativeX, relativeY);
        }
        function clickHandler(e) {
            if (paused) {
                endPause();
            }
            var relativeX = e.clientX - canvas.offsetLeft;
            var relativeY = e.clientY - canvas.offsetTop;
            
            world.handleClick(relativeX, relativeY);
        }
        
        function draw(now_ms) {
            if (now_ms - last_now_ms > 1000) {
                // At lease a second passed. Probably tab was in background.
                startPause();
            }
            if (paused) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = "30px Arial";
                ctx.fillStyle = "#000";
                ctx.textAlign = "center";
                ctx.fillText("Paused", canvas.width/2, canvas.height/2);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                world.update(now_ms - last_now_ms);
                world.draw();
                
                last_now_ms = now_ms;
                
                requestAnimationFrame(draw);
            }
        }
        
        draw(performance.now());
    </script>
    
</body>
</html>