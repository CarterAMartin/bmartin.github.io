<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Cow Abducting Simulator</title>
    <style>* { padding: 0; margin: 0; } canvas { margin: 5; background: #eeeeee; display: block; border: solid 3px blue; }</style>
</head>
<body>
    <div width="100%" style="align-content:center">
        <canvas id="myCanvas"></canvas>
    </div>
    <div style="text-align: center;">
        <h1>Cow Abducting Simulator</h1>
        <p>Try moving your mouse around and clicking. It'll get more fun when we add cows. :)</p>
        <p>By Oliver, Ben, and Carter Martin</p>
    </div>
    <!--
        var randomCowGoalPosition = function(cowWidth, cowHeight) {
            return [
            Math.random(cowWidth/2, bg.size[0] - cowWidth/2),
            bg.size[1] - 100 / 2 - cowHeight / 2,
            ];
        };
        
        var makeCow = function(startX, startY, startWidth, startHeight) {
            var cow = {
                "pos" : [ startX, startY ],
                "size" : [ startWidth, startHeight ],
                "v" : [ 0, 0],
                "maxV" : [ 3, 5 ],
                "goal" : [ startX, startY ],
                "update" : function() {
                    // Move with previous speed
                    for (var i = 0; i < 2; i++) {
                        // Move in current direction
                        this.pos[i] = this.pos[i] + this.v[i];
                        if (this.pos[i] - this.size[i] / 2 < 0) {
                            this.pos[i] = this.size[i] / 2;
                            this.v[i] = 0;
                        }
                        if (this.pos[i] + this.size[i] / 2 > bg.size[i]) {
                            this.pos[i] = bg.size[i] - this.size[i] / 2;
                            this.v[i] = 0;
                        }
                    }
                    
                    // Update speed
                    for (var i = 0; i < 2; i++) {
                        var err = this.goal[i] - this.pos[i];
                        if (err < 0) {
                            if (this.v[i] > - this.maxV[i]) {
                                this.v[i] = this.v[i] - 1;
                            }
                        } else {
                            if (this.v[i] < this.maxV[i]) {
                                this.v[i] = this.v[i] + 1;
                            }
                        }
                    }
                    
                    var xSatisfied = abs(this.goal[0] - this.pos[0]) < this.size[0]/2;
                    var ySatisfied = abs(this.goal[1] - this.pos[1]) < this.size[1]/2;
                    if (xSatisfied && ySatisfied) {
                        this.goal = randomCowGoalPosition(this.size[0], this.size=
                        [1]);
                    }
                },
                "draw": function(view) {
                    var x = this.pos[0] - view[0];
                    var y = this.pos[1] - view[1];
                    
                    //cockpit
                    fill(95, 199, 199);
                    ellipse(x, y - this.size[1] / 2, this.size[0] * 3 / 4, this.size[1] );
                    //body
                    fill(230, 230, 230);
                    ellipse(x, y, this.size[0], this.size[1]);
                    //body
                    fill(222, 22, 22);
                    ellipse(x, y, this.size[0], 2);
                }
            };
            return cow;
        };
        
        for (var i = 0; i < 10; i++) {
            var cowWidth = Math.random(50, 100);
            var cowHeight = cowWidth/2;
            var cowStartPos = randomCowGoalPosition(cowWidth, cowHeight);
            cows.push(makeCow(cowStartPos[0], cowStartPos[1],
            cowWidth,
            cowHeight
            ));
        }
        for (var i = 0; i < cows.length; i++) {
            bg.objects.push(cows[i]);
        }
        
        // debug(bg);
        
        mouseClicked = function() {
            ship.beams.push(ship.beamStartSize);
        };
        
        draw = function() {
            ship.goal = [mouseX + bg.view[0], mouseY + bg.view[1]];
            
            // Simulation
            bg.update();
            
            // Drawing
            bg.draw();
            
            return;
        };
    -->
    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        
        ctx.canvas.width = innerWidth - 100;
        ctx.canvas.height = innerHeight * .9;
        
        var rightPressed = false;
        var leftPressed  = false;
        var upPressed    = false;

        var w = 200;
        var h = 100;
        var world = {
            "size" : [w, h],
            "objects" : [],
            // pixels / m
            // Initial value is width of screen.
            "zoom" : canvas.width / w,
            "view" : [0, 0, w, h],
            "focus" : null,
            "drawBoundingBoxes" : false,
            handleMouseMove : function(relativeX, relativeY) {
                // Convert to world space
                var x = relativeX / this.zoom + this.view[0];
                var y = relativeY / this.zoom + this.view[1];
                
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleMouseMove) {
                        this.objects[i].handleMouseMove(x, y);
                    }
                }
                
                return;
            },
            handleClick : function(relativeX, relativeY) {
                var x = relativeX / this.zoom + this.view[0];
                var y = relativeY / this.zoom + this.view[1];
                
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleClick) {
                        this.objects[i].handleClick(x, y);
                    }
                }
                
                return;
            },
            handleKeyDown : function(e) {
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleKeyDown) {
                        this.objects[i].handleKeyDown(e);
                    }
                }
                return;
            },
            handleKeyUp : function(e) {
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].handleKeyUp) {
                        this.objects[i].handleKeyUp(e);
                    }
                }
                return;
            },
            "draw": function() {
                // console.log("drawing world");
                
                // Update viewport to keep focus item in center 1/2 of screen if possible
                if (this.focus) {
                    // First, adjust zoom based on bottom of focus object, such that object width is 100 at bottom and 50 at top.

                    this.zoom = 100 / this.focus.size[0];
                    //  *
                    //     (1 + (1-(this.size[1] - this.focus.pos[1] - this.focus.size[1]) / this.size[1]));
                    // if (this.zoom < 1) {
                    //     this.zoom = 1;
                    // } else if (this.zoom > 5) {
                    //     this.zoom = 5;
                    // }
                    this.view[2] = canvas.width  / this.zoom;
                    this.view[3] = canvas.height / this.zoom;

                    // Now center view. Desired state is for view and focus to have same center:
                    //   this.view[i] + this.view[i+2]/2 = focus.pos[i] + focus.size[i] / 2
                    // or
                    //   this.view[i] = focus.pos[i] + focus.size[i] / 2 - this.view[i+2]/2
                    //
                    // For stability, only correct if desired position is more than 1/4 of the screen away,
                    // and then, only as much as is needed to be that far.
                    for (var i = 0; i < 2; i++) {
                        var desiredViewPos = this.focus.pos[i] + this.focus.size[i] / 2 - this.view[i+2]/2;
                        if (this.view[i] < desiredViewPos - this.view[i+2] / 4) {
                            this.view[i] = desiredViewPos - this.view[i+2] / 4;
                        }
                        if (this.view[i] > desiredViewPos + this.view[i+2] / 4) {
                            this.view[i] = desiredViewPos + this.view[i+2] / 4;
                        }
                        // Make sure view is legal
                        if (this.view[i] < 0) {
                            this.view[i] = 0;
                        }
                        if (this.view[i] + this.view[i+2] > this.size[i]) {
                            this.view[i] = this.size[i] - this.view[i+2];
                        }
                    }
                } else {
                    this.zoom = canvas.width / this.size[0];
                    this.view[2] = canvas.height / this.zoom;
                    this.view[3] = canvas.width  / this.zoom;
                }

                for (var i = 0; i < this.objects.length; i++) {
                    var o = this.objects[i];
                    if (o.draw && !o.hidden) {
                        if (o.size) {
                            var visible =
                                (o.pos[0] + o.size[0] > this.view[0]) &&
                                (o.pos[1] + o.size[1] > this.view[1]) &&
                                (o.pos[0] < this.view[0] + this.view[2]) &&
                                (o.pos[1] < this.view[1] + this.view[3]);
                            if (visible) {
                                var zoom = this.zoom;
                                var box = [zoom * (o.pos[0] - this.view[0]),
                                        zoom * (o.pos[1] - this.view[1]),
                                        zoom * o.size[0],
                                        zoom * o.size[1]];
                                o.draw(box);
                                if (this.drawBoundingBoxes && o.pos && o.size) {
                                    ctx.strokeStyle = "green";
                                    ctx.strokeRect(box[0], box[1], box[2], box[3]);
                                }
                            }
                        } else {
                            // dimensionless object to draw
                            o.draw([0, 0, canvas.width, canvas.height]);
                        }
                    }
                }
                
                return;
            },
            "update" : function(delta_ms) {
                for (var i = 0; i < this.objects.length; i++) {
                    if (this.objects[i].update) {
                        this.objects[i].update(delta_ms);
                    }
                }
                return;
            }
        };
        function createStarField(x, y, w, h, numStars) {
            var starField = {
                pos : [x, y],
                "size" : [w, h],
                "stars" : [],
                "draw": function(box) {                
                    ctx.fillStyle = "#000";
                    ctx.fillRect(box[0], box[1], box[2], box[3]);

                    // Star position obeys zoom, but size does not.
                    var zoom = box[2] / this.size[0];
                    for (var i = 0; i < this.stars.length; i++) {
                        var star = this.stars[i];
                        var screenX = star[0] * zoom + box[0];
                        var screenY = star[1] * zoom + box[1];
                        var screenR = star[2];
                        var visible = screenX + screenR > 0 && screenX - screenR < box[2] &&
                                      screenY + screenR > 0 && screenY - screenR < box[3]; 
                        if (visible) {
                            ctx.beginPath();
                            ctx.fillStyle = "#eee";
                            ctx.arc(screenX, screenY, screenR, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.closePath();
                        }
                    }
                    return;
                }
            };
            for (var i = 0; i < numStars; i++) {
                starField.stars.push([w * Math.random(), h * Math.random(), 5 * Math.random()]);
            }
            return starField;
        }
        world.objects.push(createStarField(0, 0, world.size[0], world.size[1], world.size[0] * world.size[1] / 100));
        
        function createGroundBackground(x, y, w, h) {
            var obj = {
                pos   : [x, y],
                size  : [w, h],
                draw  : function(box) {                
                    ctx.fillStyle = "#0e0";
                    ctx.fillRect(box[0], box[1], box[2], box[3]);
                    return;
                }
            };
            return obj;
        }
        // Bottom 10% of world is ground
        world.objects.push(createGroundBackground(0, world.size[1] - 0.1 * world.size[1], world.size[0], 0.1 * world.size[1]));
        
        var updatePhysicsSub = function(delta_ms) {
            var delta_s =  delta_ms / 1000.0;

            // Move with previous speed
            for (var i = 0; i < 2; i++) {
                // Move in current direction
                this.pos[i] = this.pos[i] + this.v[i] * delta_s;
                if (this.pos[i] < 0) {
                    this.pos[i] = 0;
                    // Bounce off side wall
                    this.v[i] = Math.abs(this.v[i]);
                }
                if (this.pos[i] + this.size[i] > world.size[i]) {
                    this.pos[i] = world.size[i] - this.size[i];
                    this.v[i] = -1 * Math.abs(this.v[i]);
                }
            }
            
            // Update speed
            for (var i = 0; i < 2; i++) {
                this.v[i] = this.v[i] + this.a[i] * delta_s;
            }
            
            return;
        };
        
        function createShip (width_m) {

            // Mass is a function of the volume.
            // Approximate as sphere of 50% aluminum by volume.
            // Aluminum is 2.7 g/cm^3, which is 2,710kg/m^3
            var volume_m3 = 4 / 3 * Math.PI * (width_m / 2);
            var mass_kg = volume_m3 * 2710;

            // Define thrusters based on force required to accelerate at 1g.
            var liftingForce = mass_kg * 9.8;

            var ship = {
                "pos"  : [0, 0],
                "size" : [width_m, 0.75 * width_m],
                "v"    : [0, 0],
                "a"    : [0, 0],
                "mass_kg" : mass_kg,
                "maxV" : [50, 50],
                "autopilot" : true,
                "goal" : [0, 0],
                "jets" : [0, 0, 0],
                "jetMaxForce" : [1 * liftingForce, 3 * liftingForce, 1 * liftingForce],
                "jetAngles" : [0, 1.5 * Math.PI, Math.PI],
                "beams" : [],
                "beamStartSize" : 50,
                "beamLength" : 200,
                "bodyStyle" : { "fillStyle" : "#eee", "strokeStyle" : "#444"},
                "accentStyle" : { "fillStyle" : "#e00", "strokeStyle" : "#000000ff"},
                "cockpitStyle" : { "fillStyle" : "rgb(95, 199, 199, 100)", "strokeStyle" : "rgb(40, 100, 100)"},
                "draw": function(box) {
                    // console.log("drawing ship");
                    
                    var x = box[0];
                    var y = box[1];
                    var xCenter = box[0] + box[2] / 2;
                    var yCenter = box[1] + box[3] / 2;

                    // Draw jets last so we can see them
                    if (this.jets[0] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter - 1.0 * box[2], yCenter + box[3] / 5);
                        ctx.lineTo(xCenter - 1.2 * box[2], yCenter);
                        ctx.lineTo(xCenter - 1.0 * box[2], yCenter - box[3] / 5);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    if (this.jets[1] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter + box[2] / 5, yCenter + 1.0 * box[3]);
                        ctx.lineTo(xCenter,                    yCenter + 1.2 * box[3]);
                        ctx.lineTo(xCenter - box[2] / 5, yCenter + 1.0 * box[3]);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    if (this.jets[2] > 0) {
                        // to do: make transparency a function of force
                        ctx.fillStyle = "#ff3333";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter + 1.0 * box[2], yCenter + box[3] / 5);
                        ctx.lineTo(xCenter + 1.2 * box[2], yCenter);
                        ctx.lineTo(xCenter + 1.0 * box[2], yCenter - box[3] / 5);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    
                    // Draw beams behind body
                    for (var i = 0; i < this.beams.length; i++) {
                        // transparent green beam
                        ctx.fillStyle = "#00ff0080";
                        ctx.beginPath();
                        ctx.moveTo(xCenter, yCenter);
                        ctx.lineTo(xCenter - this.beams[i], yCenter + this.beamLength),
                        ctx.lineTo(xCenter + this.beams[i], yCenter + this.beamLength);
                        ctx.lineTo(xCenter, yCenter);
                        ctx.fill();
                        ctx.closePath();
                    }
                    
                    //body
                    ctx.fillStyle   = this.bodyStyle.fillStyle;
                    ctx.strokeStyle = this.bodyStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.66 * box[3], 0.5 * box[2], 0.33 * box[3], 0, 1.7 * Math.PI, 1.3 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();

                    //body stripe
                    ctx.fillStyle   = this.accentStyle.fillStyle;
                    ctx.strokeStyle = this.accentStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.66 * box[3], box[2]/2, 0.05 * box[3], 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                    
                    // cockpit
                    ctx.fillStyle   = this.cockpitStyle.fillStyle;
                    ctx.strokeStyle = this.cockpitStyle.strokeStyle;
                    ctx.beginPath();
                    ctx.ellipse(xCenter, y + 0.4 * box[3], 0.3 * box[2], 0.4 * box[3], 0, Math.PI, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                },
                "updatePhysics" : updatePhysicsSub,
                "updateAI" : function(delta_ms) {
                    var xCenter = this.pos[0] + this.size[0] / 2;
                    var yCenter = this.pos[1] + this.size[1] / 2;

                    // Run autopilot
                    if (this.goal) {
                        var xErr = this.goal[0] - xCenter;
                        var yErr = this.goal[1] - yCenter;

                        // Fire horizontal jets toward goal
                        if (this.v[0] < -this.maxV[0]) {
                            // Emergency shut off
                            this.jets[2] = 0;
                        } else {
                            if (xErr < 3 * this.v[0]) {
                                // Accelerate toward goal
                                this.jets[2] = 1;
                            } else {
                                // Coast
                                this.jets[2] = 0;
                            }
                        }
                        
                        if (this.v[0] > this.maxV[0]) {
                            // Emergency shut off
                            this.jets[0] = 0;
                        } else {
                            if (xErr > 3 * this.v[0]) {
                                // Accelerate toward goal
                                this.jets[0] = 1;
                            } else {
                                // Coast
                                this.jets[0] = 0;
                            }
                        }
                        
                        // Fire vertical jets toward goal
                        if (this.v[0] <= -this.maxV[0]) {
                            // Emergency thruster shut off
                            this.jets[1] = 0;
                        } else {
                            if (yErr < 3 * this.v[1]) {
                                // full power
                                this.jets[1] = 1;
                            } else {
                                this.jets[1] = 0;
                            }
                        }
                    }
                    return;
                },
                "update" : function(delta_ms) {

                    if (this.autopilot) {
                        this.updateAI(delta_ms);
                    }
                    
                    // Adjust acceleration based on input forces
                    var f = [0, 0];

                    // Drag can be modeled more accurately than this.
                    
                    // Density in atmospheres
                    var density = 1;
                    f[0] = f[0] - 0.1 * density * this.v[0] * this.v[0];
                    f[1] = f[1] - 0.1 * density * this.v[1] * this.v[1];

                    // Gravity
                    //   F = m * a => F = m * g
                    if (this.mass_kg) {
                        var g = 9.8;
                        f[1] = f[1] + g * this.mass_kg;
                    }

                    // Jets
                    for (var i = 0; i < this.jets.length; i++) {
                        var force = this.jets[i] * this.jetMaxForce[i];
                        f[0] = f[0] + Math.cos(this.jetAngles[i]) * force;
                        f[1] = f[1] + Math.sin(this.jetAngles[i]) * force;
                    }

                    this.a[0] = f[0] / this.mass_kg;
                    this.a[1] = f[1] / this.mass_kg;
                    
                    // Move based on acceleration
                    this.updatePhysics(delta_ms);
                    
                    // Update tractor beams
                    for (var i = 0; i < this.beams.length; i++) {
                        this.beams[i] = this.beams[i] - 1;
                    }
                    // Delete empty beams
                    var beamNum = 0;
                    while (beamNum < this.beams.length) {
                        if (this.beams[beamNum] <= 0) {
                            this.beams.splice(beamNum, 1);
                        } else {
                            beamNum = beamNum + 1;
                        }
                    }
                    
                    // Try to pick up cows
                    for (var i = 0; i < world.objects.length; i++) {
                        // Check if mob is in beam
                        if (world.objects[i].v) {
                            var mob = world.objects[i];
                            if (mob.pos[1] > this.pos[1] && mob.pos[1] < this.pos[1] + this.beamLength) {
                                // Could be in beam
                                for (var j = 0; j < this.beams.length; j++) {
                                    var beamWidth = this.beams[j];
                                    if (mob.pos[0] > this.pos[0] - beamWidth &&
                                    mob.pos[0] < this.pos[0] + beamWidth
                                    ) {
                                        // In beam
                                        mob.v[1] = mob.v[1] - 1;
                                    }
                                }
                            }
                        }
                    }                
                },
                handleMouseMove : function(x, y) {
                    this.autopilot = true;

                    // Scale goal extra when in the border region
                    this.goal = [x, y];
                    for (var i = 0; i < 2; i++) {
                        if (this.goal[i] < world.view[i] + 0.25 * world.view[i+2]) {
                            this.goal[i] = 0;
                        }
                        if (this.goal[i] < 0) {
                            this.goal[i] = 0;
                        }
                        if (this.goal[i] > world.view[i] + 0.75 * world.view[i+2]) {
                            this.goal[i] = world.size[i];
                        }
                        if (this.goal[i] > world.size[i]) {
                            this.goal[i] = works.size[i];;
                        }
                    }
                    return;
                },
                handleClick : function(x, y) {
                    this.beams.push(this.beamStartSize);
                    return;
                },
                handleKeyDown : function(e) {
                    if (this.autopilot) {
                        // Turn off all jets and turn off autopilot
                        for (var i = 0; i < this.jets.length; i++) {
                            this.jets[i] = 0;
                        }
                        this.autopilot = false;
                    }
                    if (e.keyCode == 39 || e.keyCode == 68) {
                        // pushed right
                        this.jets[0] = 1;
                    } else if(e.keyCode == 37 || e.keyCode == 65) {
                        // pushed left
                        this.jets[2] = 1;
                    } else if(e.keyCode == 38 || e.keyCode == 87) {
                        // pushed up
                        this.jets[1] = 1;
                    } else if(e.keyCode == 66) {
                        // pushed b
                        world.drawBoundingBoxes = true;
                    } else {
                        console.log(e.keyCode);
                    }
                    return;
                },
                handleKeyUp : function(e) {
                    if (e.keyCode == 39 || e.keyCode == 68) {
                        // pushed right or d
                        this.jets[0] = 0;
                    } else if(e.keyCode == 37 || e.keyCode == 65) {
                        // pushed left or a
                        this.jets[2] = 0;
                    } else if(e.keyCode == 38 || e.keyCode == 87) {
                        // pushed up or w
                        this.jets[1] = 0;
                    } else if(e.keyCode == 66) {
                        // pushed b
                        world.drawBoundingBoxes = false;
                    }
                    return;
                }

            };
            return ship;
        }

        function createSplashScreen() {
            var o = {
                hidden : false,
                draw: function(view) {
                    ctx.font = "30px Arial";
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText("Cow Abducting Simulator", canvas.width/2, canvas.height/2);
                    
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "center";
                    ctx.fillText("Click to Start", canvas.width/2, canvas.height * .75);
                    return;
                },
                handleClick : function(x, y) {
                    if (this.hidden) {
                        return;
                    }
                    this.hidden = true;
                    // Initial ship is 100m
                    var ship = createShip(5);
                    world.objects.push(ship);
                    world.focus = ship;
                    return;
                }
            };
            return o;
        }
        
        // Must be last object on stack
        world.objects.push(createSplashScreen());
        
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);
        document.addEventListener("mousemove", mouseMoveHandler, false);
        document.addEventListener("click", clickHandler, false);
        
        function keyDownHandler(e) {
            world.handleKeyDown(e);
        }
        function keyUpHandler(e) {
            world.handleKeyUp(e);
        }
        function mouseMoveHandler(e) {
            var relativeX = e.clientX - canvas.offsetLeft;
            var relativeY = e.clientY - canvas.offsetTop;
            
            world.handleMouseMove(relativeX, relativeY);
        }
        function clickHandler(e) {
            var relativeX = e.clientX - canvas.offsetLeft;
            var relativeY = e.clientY - canvas.offsetTop;
            
            world.handleClick(relativeX, relativeY);
        }
        
        var last_now_ms = performance.now();
        function draw(now_ms) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            world.update(now_ms - last_now_ms);
            world.draw();
            
            last_now_ms = now_ms;
            requestAnimationFrame(draw);
        }
        
        draw(performance.now());
    </script>
    
</body>
</html>